<!DOCTYPE html>
<html>
	<head>
		<title></title>
		<script
			type="text/javascript"
			src="auxiliars.js"></script>
		<script
			type="text/javascript"
			src="shader.js"></script>
		<script
			type="text/javascript"
			src="ubo.js"></script>
		<script
			type="text/javascript"
			src="cube.js"></script>
		<script
			type="text/javascript"
			src="gl-matrix.js"></script>
		<script
			type="text/javascript"
			src="geometry.js"></script>
		<style type="text/css">
			canvas {
				width: 100%;
				height: 100%;
				display: block;
			}
			body {
				margin: 0;
				overflow: hidden;
			}
		</style>
		<script type="text/javascript">
			const mat4 = glMatrix.mat4;
			const vec3 = glMatrix.vec3;
			const vec2 = glMatrix.vec2;
			// Converts from degrees to radians.
			Math.radians = function (degrees) {
				return (degrees * Math.PI) / 180;
			};

			// Converts from radians to degrees.
			Math.degrees = function (radians) {
				return (radians * 180) / Math.PI;
			};
		</script>
		<!-- prettier-ignore -->
		<script id="shader-vs" type="x-shader/x-vertex">#version 300 es
        precision mediump float;

        layout (location = 0) in vec3 aPos;
		layout (location = 1) in vec3 aNormal;
		layout (location = 2) in vec2 aTexCoord;

		// Unif. Buffer Object
        uniform UBO {
            mat4 projection;
            mat4 view;
        };

		uniform mat4 model;

		out vec2 TexCoord;

		void main()
        {
			TexCoord = aTexCoord;
        	gl_Position = projection * view * model * vec4(aPos, 1.0);
        }
        </script>
		<!-- prettier-ignore -->
		<script
			id="shader-fs"
			type="x-shader/x-fragment">#version 300 es
		precision mediump float;
		
		in vec2 TexCoord;
		
		uniform sampler2D uTexture;
		
		out vec4 FragColor;
		
		void main() {
			FragColor = texture(uTexture, TexCoord);
		}
		</script>
	</head>
	<body>
		<canvas
			id="myCanvas"
			width="500"
			height="500"></canvas>
		<script type="text/javascript">
			const gl = createContext("myCanvas");
			const canvas = document.getElementById('myCanvas'); 
			// ---------------------------------------------------
			// CREAR TODOS LOS SHADERPROGRAMS QUE NECESITES
			// ---------------------------------------------------
			let shaderProgram = new ShaderProgram();
			shaderProgram.createVertexShader(
				document.getElementById("shader-vs").text
			);
			shaderProgram.createFragmentShader(
				document.getElementById("shader-fs").text
			);
			shaderProgram.compile();
			shaderProgram.link();
			shaderProgram.autocatching();


			 // variables to control translation and rotation
			var cameraPosition = vec3.fromValues(0.0, 0.0, -20.0); //Camera pointing at origin
			var cameraFront = vec3.fromValues(0.0, 0.0, 1.0);
			var cameraUp = [0, 1, 0];
	
			let lastX = 250;
			let lastY = 250;
			let firstMouse = true;
			let yaw = 70.0;
			let pitch = 0.0;
			// ---------------------------------------------------
			// CREAMOS EL UBO Y VINCULAMOS TODOS LOS SHADERPROGRAM
			// QUE HARÁN USO DE ESTE UBO
			// ---------------------------------------------------
			// TODO: ShaderProgram debe ser algún Programa que crees y que contenga el UBO
			let ubo = new UBO("UBO", shaderProgram, ["projection", "view"]); // Aquí añade todos los uniformes que quieres compartir
			console.log(ubo);

			// TODO: Realiza esta llamada con cada programa que vayas a utilizar
			ubo.attachProgram(shaderProgram);

			// ---------------------------------------------------
			// CREA EL VAO, VBO'S Y EBO PARA LA ESFERA (createSphere())
			// CREA EL VAO, VBO'S Y EBO PARA EL ANILLO (createRing())
			//  {
			//    "vertices": vertices,
			//    normals: normals,
			//    texCoords: uvs,
			//    indices: indices
			// }
			// ---------------------------------------------------
			// TODO: Crea una esfera y sube la geometría a la tarjeta gráfica
			const sphereGeo = createSphere();
			const ringGeo = createRing();

			const VAO = gl.createVertexArray();
			const VBO = gl.createBuffer();
			const VBO2 = gl.createBuffer();
			const VBO3 = gl.createBuffer();
			const EBO = gl.createBuffer();

			gl.bindVertexArray(VAO);

			// position attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
			gl.bufferData(
				gl.ARRAY_BUFFER,
				new Float32Array(sphereGeo.vertices),
				gl.STATIC_DRAW
			);

			gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(0);

			// normal attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, VBO2);
			gl.bufferData(
				gl.ARRAY_BUFFER,
				new Float32Array(sphereGeo.normals),
				gl.STATIC_DRAW
			);

			gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(1);

			// texCoord attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, VBO3);
			gl.bufferData(
				gl.ARRAY_BUFFER,
				new Float32Array(sphereGeo.texCoords),
				gl.STATIC_DRAW
			);

			gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(2);

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
			gl.bufferData(
				gl.ELEMENT_ARRAY_BUFFER,
				new Uint32Array(sphereGeo.indices),
				gl.STATIC_DRAW
			);

			const sunTexture = loadTexture("../resources/sun.png");
			const earthTexture = loadTexture("../resources/earth_diffuse.jpg");

			function loadTexture(url) {
				const texture = gl.createTexture();
				const image = new Image();

				image.onload = function () {
					gl.bindTexture(gl.TEXTURE_2D, texture);
					gl.texImage2D(
						gl.TEXTURE_2D,
						0,
						gl.RGBA,
						gl.RGBA,
						gl.UNSIGNED_BYTE,
						image
					);
					gl.generateMipmap(gl.TEXTURE_2D);
					gl.texParameteri(
						gl.TEXTURE_2D,
						gl.TEXTURE_MIN_FILTER,
						gl.LINEAR_MIPMAP_LINEAR
					);
					gl.texParameteri(
						gl.TEXTURE_2D,
						gl.TEXTURE_MAG_FILTER,
						gl.LINEAR
					);
				};

				image.src = url;
				return texture;
			}

			function renderModelTexture(proj, view, model, texture) {
				shaderProgram.setUniformMat4("model", model);

				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				shaderProgram.setUniform1i("uTexture", 1);

				ubo.uploadData("projection", proj);
				ubo.uploadData("view", view);
				ubo.uploadAll();

				gl.bindVertexArray(VAO);

				gl.drawElements(
					gl.TRIANGLES,
					sphereGeo.indices.length,
					gl.UNSIGNED_INT,
					0
				);
			}

			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

			function renderFunc(time) {
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				gl.enable(gl.DEPTH_TEST);

				time *= 0.001; // to seconds

				const proj = mat4.create();
				mat4.perspective(
					proj,
					Math.radians(60.0),
					gl.canvas.width / gl.canvas.height,
					0.001,
					1000.0
				);
				const view = mat4.create();
				mat4.lookAt(view, cameraPosition, vec3.add(vec3.create(), cameraPosition, cameraFront), cameraUp);
				// mat4.translate(view, view, [0.0, 0.0, -20.0]);

				// Sun model
				const sunModel = mat4.create();
				const sunRotationItSelf = time * 25.0;

				mat4.translate(sunModel, sunModel, [0.0, 6.5, 0.0]);
				mat4.rotate(sunModel, sunModel, Math.radians(sunRotationItSelf), [0.0, 1.0, 0.0]);

				// Earth model
				const earthModel = mat4.create();
				const earthRotationAroundSun = time * 0.5;
				const earthRotationItSelf = time * 30.0;
				const earthOrbitRadius = 5.0; // Radius of the earth's orbit

				const earthPositionX = Math.cos(earthRotationAroundSun) * earthOrbitRadius;
				const earthPositionZ = Math.sin(earthRotationAroundSun) * earthOrbitRadius;
				mat4.translate(earthModel, earthModel, [earthPositionX, 6.5, earthPositionZ]);
				mat4.rotate(earthModel, earthModel, Math.radians(earthRotationItSelf), [0.0, 1.0, 0.0]);

				// Bind
				shaderProgram.bind();

				// Render the sun
				renderModelTexture(proj, view, sunModel, sunTexture);

				// Render the earth
				renderModelTexture(proj, view, earthModel, earthTexture);

				requestAnimationFrame(renderFunc);
			}

			document.addEventListener("pointerlockchange", lockChangeAlert, false);
			document.addEventListener("keydown", function (event) {
				/*
					65 => A
					68 => D
					83 => S
					87 => W
					81 => Q
					69 => E

					37 => Flecha izq
					39 => Fecha drcha
					38 => Fecha arriba
					40 => Fecha abajo

				*/
				var cameraSpeed = 0.4; // Speed
				const cameraFrontNormalized=vec3.normalize(vec3.create(), cameraFront);
				const cameraRight = vec3.cross(vec3.create(), cameraFrontNormalized, cameraUp);
				switch (event.keyCode) {
					//translation
					case 87: 
					vec3.add(cameraPosition, cameraPosition, vec3.scale(vec3.create(), cameraFrontNormalized, cameraSpeed));
						break;
					case 68: 
						vec3.add(cameraPosition, cameraPosition, vec3.scale(vec3.create(), cameraRight, cameraSpeed));

						break;
					case 83: 
						vec3.sub(cameraPosition, cameraPosition, vec3.scale(vec3.create(), cameraFrontNormalized, cameraSpeed));
						break;
					case 65: 
						vec3.sub(cameraPosition, cameraPosition, vec3.scale(vec3.create(), cameraRight, cameraSpeed));
						break;
					case 81: 
						cameraPosition[1] += cameraSpeed;
						break;
               	 	case 69:
						cameraPosition[1] -= cameraSpeed;
						break;
				}
			
			});

			function mouse_callback(event) {
				
			
				let x=event.movementX;
				let y=event.movementY;
				const sensitivity = 0.1;

				if (firstMouse) {
					lastX = x;
					lastY = y;
					firstMouse = false;
				}
				else{
					x+=lastX;
					y+=lastY;
				}
			
				if (pitch > 89.0) pitch = 89.0;
				if (pitch < -89.0) pitch = -89.0;
				
				const xoffset = x - lastX;
				const yoffset = lastY - y;
				lastX = x;
				lastY = y;
	
				yaw += xoffset * sensitivity;
				pitch += yoffset * sensitivity;

				const direction = vec3.create();
				direction[0] = Math.cos(Math.radians(yaw)) * Math.cos(Math.radians(pitch));
				direction[1] = Math.sin(Math.radians(pitch));
				direction[2] = Math.sin(Math.radians(yaw)) * Math.cos(Math.radians(pitch));
				vec3.normalize(cameraFront, direction);
				
			}

			//Mouse movement event listener 
			canvas.addEventListener("click", async () => {
				if(!document.pointerLockElement) {
					await canvas.requestPointerLock({
					unadjustedMovement: true,
					});
				}
				});
			
			
			function lockChangeAlert() {
				if (document.pointerLockElement === canvas) {
					console.log("The pointer lock status is now locked");
					document.addEventListener("mousemove", mouse_callback, false);
				} else {
					console.log("The pointer lock status is now unlocked");
					document.removeEventListener("mousemove", mouse_callback, false);
				}
			}

			function resizeCanvas() {
				const canvas = gl.canvas;
				// Lookup the size the browser is displaying the canvas in CSS pixels.
				const displayWidth = canvas.clientWidth;
				const displayHeight = canvas.clientHeight;

				// Check if the canvas is not the same size.
				const needResize =
					canvas.width !== displayWidth ||
					canvas.height !== displayHeight;

				if (needResize) {
					// Make the canvas the same size
					canvas.width = displayWidth;
					canvas.height = displayHeight;
					gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
				}
			}

			window.addEventListener("resize", resizeCanvas);
			resizeCanvas();

			renderFunc(0.0);
		</script>
	</body>
</html>
