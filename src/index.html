<!DOCTYPE html>
<html>
	<head>
		<title></title>
		<script
			type="text/javascript"
			src="auxiliars.js"></script>
		<script
			type="text/javascript"
			src="shader.js"></script>
		<script
			type="text/javascript"
			src="ubo.js"></script>
		<script
			type="text/javascript"
			src="cube.js"></script>
		<script
			type="text/javascript"
			src="gl-matrix.js"></script>
		<script
			type="text/javascript"
			src="geometry.js"></script>
		<style type="text/css">
			canvas {
				width: 100%;
				height: 100%;
				display: block;
			}
			body {
				margin: 0;
				overflow: hidden;
			}
		</style>
		<script type="text/javascript">
			const mat4 = glMatrix.mat4;
			const vec3 = glMatrix.vec3;
			const vec2 = glMatrix.vec2;
			// Converts from degrees to radians.
			Math.radians = function (degrees) {
				return (degrees * Math.PI) / 180;
			};

			// Converts from radians to degrees.
			Math.degrees = function (radians) {
				return (radians * 180) / Math.PI;
			};
		</script>
		<!-- prettier-ignore -->
		<script id="sun-vs" type="x-shader/x-vertex">#version 300 es
			precision mediump float;
			
			layout (location = 0) in vec3 aPos;
			layout (location = 2) in vec2 aTexCoord;
			
			// Uniform Buffer Object
			uniform UBO {
				mat4 projection;
				mat4 view;
			};
			
			uniform mat4 model;
			
			out vec2 TexCoord;
			
			void main() {
				TexCoord = aTexCoord;
				gl_Position = projection * view * model * vec4(aPos, 1.0);
			}
		</script>

		<!-- prettier-ignore -->
		<script id="sun-fs" type="x-shader/x-fragment">#version 300 es
			precision mediump float;

			in vec2 TexCoord;

			uniform sampler2D uTexture;

			out vec4 FragColor;

			void main() {
				FragColor = texture(uTexture, TexCoord);
			}
		</script>

		<!-- prettier-ignore -->
		<script id="planets-vs" type="x-shader/x-vertex">#version 300 es
			precision mediump float;
			
			layout (location = 0) in vec3 aPos;
			layout (location = 1) in vec3 aNormal;
			layout (location = 2) in vec2 aTexCoord;
			
			// Uniform Buffer Object
			uniform UBO {
				mat4 projection;
				mat4 view;
			};
			
			uniform mat4 model;
			
			out vec2 TexCoord;
			out vec3 Normal;
			out vec3 FragPos;
			
			void main() {
				TexCoord = aTexCoord;
				FragPos = vec3(model * vec4(aPos, 1.0));
				Normal = mat3(transpose(inverse(model))) * aNormal;  
				gl_Position = projection * view * model * vec4(aPos, 1.0);
			}
		</script>

		<!-- prettier-ignore -->
		<script id="planets-fs" type="x-shader/x-fragment">#version 300 es
			precision mediump float;
			
			in vec2 TexCoord;
			in vec3 Normal;
			in vec3 FragPos;

			out vec4 FragColor;
			
			uniform sampler2D uTexture;
			uniform sampler2D uNormalTexture;
			uniform sampler2D uSpecularTexture;
			
			uniform vec3 lightColor;
			uniform vec3 lightPos;
			uniform vec3 viewPos;
			
			uniform float lightConstant;
			uniform float lightLinear;
			uniform float lightQuadratic;
			
			
			void main() {
				// Texture color
				vec3 color = texture(uTexture, TexCoord).rgb;
			
				// Normal mapping
				vec3 normal =  texture(uNormalTexture, TexCoord).rgb + Normal;
				normal = normalize(normal * 2.0 - 1.0)  ;
				
			
				// Lighting calculations
				vec3 ambient = 0.1 * lightColor;
			
				vec3 lightDir = normalize(lightPos - FragPos);
				float diff = max(dot(normal, lightDir), 0.0);
				vec3 diffuse = diff * lightColor;
			
				// Specular mapping
				float specularStrength = texture(uSpecularTexture, TexCoord).r;
				vec3 viewDir = normalize(viewPos - FragPos);
				vec3 reflectDir = reflect(-lightDir, normal);
				float spec = pow(max(dot(viewDir, reflectDir), 1.0), 32.0);
				vec3 specular = specularStrength * spec * lightColor;

				// Attenuation
				float distance = length(lightPos - FragPos);
				float attenuation = 1.0 / (lightConstant + lightLinear * distance + lightQuadratic * distance * distance);
				
			
				vec3 result = (ambient + diffuse + specular) * color * attenuation;
				// Only illuminate the side facing the light
				if(diff <= 0.0) {
					result = (ambient) * specular; // Apply only ambient light on the shadowed side
    			}

				FragColor = vec4(result, 1.0);
			}
		</script>
	</head>
	<body>
		<canvas
			id="myCanvas"
			width="500"
			height="500"></canvas>
		<script type="text/javascript">
			const gl = createContext("myCanvas");
			const canvas = document.getElementById("myCanvas");
			// ---------------------------------------------------
			// CREAR TODOS LOS PROGRAMAS QUE NECESITES
			// ---------------------------------------------------
			function loadPlanetProgram(shaderProgram){
				shaderProgram.createVertexShader(
				document.getElementById("planets-vs").text
				);
				shaderProgram.createFragmentShader(
					document.getElementById("planets-fs").text
				);
				shaderProgram.compile();
				shaderProgram.link();
				shaderProgram.autocatching();
			}

			const sphereProgram = new ShaderProgram();
			sphereProgram.createVertexShader(
				document.getElementById("sun-vs").text
			);
			sphereProgram.createFragmentShader(
				document.getElementById("sun-fs").text
			);

			sphereProgram.compile();
			sphereProgram.link();
			sphereProgram.autocatching();

			const saturnRingProgram = new ShaderProgram();
			saturnRingProgram.createVertexShader(
				document.getElementById("sun-vs").text
			);
			saturnRingProgram.createFragmentShader(
				document.getElementById("sun-fs").text
			);

			saturnRingProgram.compile();
			saturnRingProgram.link();
			saturnRingProgram.autocatching();

			const moonProgram = new ShaderProgram();
			loadPlanetProgram(moonProgram);

			const earthProgram = new ShaderProgram();
			loadPlanetProgram(earthProgram);

			const mercuryProgram = new ShaderProgram();
			loadPlanetProgram(mercuryProgram);

			const venusProgram = new ShaderProgram();
			loadPlanetProgram(venusProgram);

			const marsProgram = new ShaderProgram();
			loadPlanetProgram(marsProgram);

			const jupiterProgram = new ShaderProgram();
			loadPlanetProgram(jupiterProgram);

			const saturnProgram = new ShaderProgram();
			loadPlanetProgram(saturnProgram);

			

			// variables to control translation and rotation
			var cameraPosition = vec3.fromValues(0.0, 0.0, -40.0); //Camera pointing at origin
			var cameraFront = vec3.fromValues(0.0, -6.0, 20.0);
			var cameraUp = vec3.fromValues(0.0, 1.0, 0.0);

			let lastX = 250;
			let lastY = 250;
			let firstMouse = true;
			let yaw = 70.0;
			let pitch = 0.0;
			// ---------------------------------------------------
			// CREAMOS EL UBO Y VINCULAMOS TODOS LOS PROGRAMAS
			// QUE HARÁN USO DE ESTE UBO
			// ---------------------------------------------------
			// TODO: PROGRAMA debe ser algún Programa que crees y que contenga el UBO
			const ubo = new UBO("UBO", sphereProgram, ["projection", "view"]);

			// Aquí añade todos los uniformes que quieres compartir

			// TODO: Realiza esta llamada con cada programa que vayas a utilizar
			ubo.attachProgram(sphereProgram);
			ubo.attachProgram(earthProgram);
			ubo.attachProgram(moonProgram);
			ubo.attachProgram(mercuryProgram);
			ubo.attachProgram(venusProgram);
			ubo.attachProgram(marsProgram);
			ubo.attachProgram(jupiterProgram);
			ubo.attachProgram(saturnProgram);
			ubo.attachProgram(saturnRingProgram);



			// ---------------------------------------------------
			// CREA EL VAO, VBO'S Y EBO PARA LA ESFERA (createSphere())
			// CREA EL VAO, VBO'S Y EBO PARA EL ANILLO (createRing())
			//  {
			//    "vertices": vertices,
			//    normals: normals,
			//    texCoords: uvs,
			//    indices: indices
			// }
			// ---------------------------------------------------
			// TODO: Crea una esfera y sube la geometría a la tarjeta gráfica
			const sphereGeo = createSphere();
			const ringGeo = createRing();

			const VAO = gl.createVertexArray();
			const VBO = gl.createBuffer();
			const VBO2 = gl.createBuffer();
			const VBO3 = gl.createBuffer();
			const EBO = gl.createBuffer();

			const ringVAO = gl.createVertexArray();
			const ringVBO = gl.createBuffer();
			const ringVBO2 = gl.createBuffer();
			const ringVBO3 = gl.createBuffer();
			const ringEBO = gl.createBuffer();

			gl.bindVertexArray(VAO);

			// position attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
			gl.bufferData(
				gl.ARRAY_BUFFER,
				new Float32Array(sphereGeo.vertices),
				gl.STATIC_DRAW
			);

			gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(0);

			// normal attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, VBO2);
			gl.bufferData(
				gl.ARRAY_BUFFER,
				new Float32Array(sphereGeo.normals),
				gl.STATIC_DRAW
			);

			gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(1);

			// texCoord attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, VBO3);
			gl.bufferData(
				gl.ARRAY_BUFFER,
				new Float32Array(sphereGeo.texCoords),
				gl.STATIC_DRAW
			);

			gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(2);

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
			gl.bufferData(
				gl.ELEMENT_ARRAY_BUFFER,
				new Uint32Array(sphereGeo.indices),
				gl.STATIC_DRAW
			);

			gl.bindVertexArray(ringVAO);

			// position attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, ringVBO);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ringGeo.vertices), gl.STATIC_DRAW);
			gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(0);

			// normal attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, ringVBO2);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ringGeo.normals), gl.STATIC_DRAW);
			gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(1);

			// texCoord attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, ringVBO3);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ringGeo.texCoords), gl.STATIC_DRAW);
			gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(2);

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ringEBO);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(ringGeo.indices), gl.STATIC_DRAW);


			const sunTexture = loadTexture("../resources/sun.png");
			const earthTexture = loadTexture("../resources/earth_diffuse.jpg");
			const earthNormalTexture = loadTexture(
				"../resources/earth_normal.jpg"
			);
			const earthSpecularTexture = loadTexture(
				"../resources/earth_specular.jpg"
			);
			const mercuryTexture = loadTexture(
				"../resources/mercury_diffuse.jpg"
			);
			const moonTexture = loadTexture("../resources/moon.png");

			const venusTexture = loadTexture("../resources/venus_diffuse.jpg");

			const marsTexture = loadTexture("../resources/mars_diffuse.jpg");

			const jupiterTexture = loadTexture("../resources/jupiter_diffuse.jpg");

			const saturnTexture = loadTexture("../resources/saturn_diffuse.jpg");

			const saturnRingTexture = loadTexture("../resources/saturn_ring_diffuse.png");


			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

			function loadTexture(url) {
				const texture = gl.createTexture();
				const image = new Image();

				image.onload = function () {
					gl.bindTexture(gl.TEXTURE_2D, texture);
					gl.texImage2D(
						gl.TEXTURE_2D,
						0,
						gl.RGBA,
						gl.RGBA,
						gl.UNSIGNED_BYTE,
						image
					);
					gl.generateMipmap(gl.TEXTURE_2D);
					gl.texParameteri(
						gl.TEXTURE_2D,
						gl.TEXTURE_MIN_FILTER,
						gl.LINEAR_MIPMAP_LINEAR
					);
					gl.texParameteri(
						gl.TEXTURE_2D,
						gl.TEXTURE_MAG_FILTER,
						gl.LINEAR
					);
				};

				image.src = url;
				return texture;
			}

			const renderPlanet = (model, shaderProgramP, texture, normalTexture, specularTexture) => {
				shaderProgramP.bind();
				shaderProgramP.setUniformMat4("model", model);
				shaderProgramP.setUniform3f("lightPos", 0.0, 0.0, 0.0);
				shaderProgramP.setUniform3f("viewPos", cameraPosition);
				shaderProgramP.setUniform3f("lightColor", 2, 2, 2);

				shaderProgramP.setUniform1f("lightConstant", 1.0);
                shaderProgramP.setUniform1f("lightLinear", 0.09);
                shaderProgramP.setUniform1f("lightQuadratic", 0.032);

				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				shaderProgramP.setUniform1i("uTexture", 1);

				gl.activeTexture(gl.TEXTURE2);
				gl.bindTexture(gl.TEXTURE_2D, normalTexture);
				shaderProgramP.setUniform1i("uNormalTexture", 2);

				gl.activeTexture(gl.TEXTURE3);
				gl.bindTexture(gl.TEXTURE_2D, specularTexture);
				shaderProgramP.setUniform1i("uSpecularTexture", 3);

				gl.bindVertexArray(VAO);
				gl.drawElements(
					gl.TRIANGLES,
					sphereGeo.indices.length,
					gl.UNSIGNED_INT,
					0
				);
			};

			function renderSun(model, texture, shaderProgram) {
				shaderProgram.bind();
				shaderProgram.setUniformMat4("model", model);

				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				shaderProgram.setUniform1i("uTexture", 1);

				gl.bindVertexArray(VAO);
				gl.drawElements(
					gl.TRIANGLES,
					sphereGeo.indices.length,
					gl.UNSIGNED_INT,
					0
				);
			}

			function assignAttributes(pModel, pScale, pRotationPeriod, pOrbitalPeriod, pOrbitalRadius, pInitialPosition, pOrbitRotation, pPosition ){
				mat4.rotate(
					pOrbitRotation,
					pOrbitRotation,
					pOrbitalPeriod,
					[0.0, 1.0, 0.0]
				);

				// Apply the rotation matrix to the mercury's initial position
				vec3.transformMat4(
					pPosition,
					pInitialPosition,
					pOrbitRotation
				);

				mat4.translate(pModel, pModel, pPosition);
				mat4.scale(pModel, pModel, [
					pScale,
					pScale,
					pScale,
				]);
				mat4.rotate(
					pModel,
					pModel,
					Math.radians(pRotationPeriod),
					[0.0, 1.0, 0.0]
				);

			}

			// Function to render the ring
			const renderRing = (model, shaderProgram, texture) => {
				shaderProgram.bind();
				shaderProgram.setUniformMat4("model", model);
				
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				shaderProgram.setUniform1i("uTexture", 1);
				gl.bindVertexArray(ringVAO);
				gl.drawElements(gl.TRIANGLES, ringGeo.indices.length, gl.UNSIGNED_INT, 0);
			};

			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

			function renderFunc(time) {
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				gl.enable(gl.DEPTH_TEST);

				time *= 0.001; // to seconds

				const proj = mat4.create();
				mat4.perspective(
					proj,
					Math.radians(60.0),
					gl.canvas.width / gl.canvas.height,
					0.001,
					1000.0
				);
				const view = mat4.create();
				mat4.lookAt(
					view,
					cameraPosition,
					vec3.add(vec3.create(), cameraPosition, cameraFront),
					cameraUp
				);
				// mat4.translate(view, view, [0.0, 0.0, -20.0]);

				// Sun model
				const sunModel = mat4.create();
				const sunScale = 2.0;
				const sunPosition = [0.0, 0.0, 0.0];
				const sunRotationPeriod = time * 20.0;

				mat4.translate(sunModel, sunModel, sunPosition);
				mat4.scale(sunModel, sunModel, [sunScale, sunScale, sunScale]);
				mat4.rotate(
					sunModel,
					sunModel,
					Math.radians(sunRotationPeriod),
					[0.0, 1.0, 0.0]
				);

				// Earth model
				const earthModel = mat4.create();
				const earthScale = 1.0;
				const earthRotationPeriod = time * 60.0;
				const earthOrbitalPeriod = time * 1.4; // Radius of the earth's orbit
				const earthOrbitRadius = 10.0;

				// Initial Earth position in the xz-plane
				const earthInitialPosition = [earthOrbitRadius, 0.0, 0.0];

				// Create a rotation matrix for the Earth's orbit around the Sun
				const earthOrbitRotation = mat4.create();
				const earthPosition = vec3.create();
				assignAttributes(earthModel, earthScale, earthRotationPeriod, 
					earthOrbitalPeriod, earthOrbitRadius, earthInitialPosition, 
					earthOrbitRotation,earthPosition)
				

				// Moon model

				const moonModel = mat4.create();
				const moonScale = 0.3;
				const moonOrbitalPeriod = time * 2.0;
				const moonRotationPeriod = time * 35.0;
				const moonOrbitRadius = 1.5; // Radius of the moon's orbit

				const moonInitialPosition = [moonOrbitRadius, 0.0, 0.0];

				const moonOrbitRotation = mat4.create();
				mat4.rotate(
					moonOrbitRotation,
					moonOrbitRotation,
					moonOrbitalPeriod,
					[0.0, 1.0, 0.0]
				);

				// Apply the rotation matrix to the Moon's initial position relative to the Earth
				const moonPositionRelativeToEarth = vec3.transformMat4(
					vec3.create(),
					moonInitialPosition,
					moonOrbitRotation
				);

				// Calculate the Moon's position in the world coordinates
				const moonPosition = vec3.add(
					vec3.create(),
					moonPositionRelativeToEarth,
					earthPosition
				);

				mat4.translate(moonModel, moonModel, moonPosition);
				mat4.scale(moonModel, moonModel, [
					moonScale,
					moonScale,
					moonScale,
				]);
				mat4.rotate(
					moonModel,
					moonModel,
					Math.radians(moonRotationPeriod),
					[0.0, 1.0, 0.0]
				);

				//Mercury model
				const mercuryModel = mat4.create();
				const mercuryScale = 0.5;
				const mercuryRotationPeriod = time * 60.0;
				const mercuryOrbitalPeriod = time * 3.0; // Radius of the mercury's orbit
				const mercuryOrbitRadius = 3.87;

				// Initial mercury position in the xz-plane
				const mercuryInitialPosition = [mercuryOrbitRadius, 0.0, 0.0];

				// Create a rotation matrix for the mercury's orbit around the Sun
				const mercuryOrbitRotation = mat4.create();
				const mercuryPosition = vec3.create();
				assignAttributes(mercuryModel, mercuryScale, mercuryRotationPeriod, 
					mercuryOrbitalPeriod, mercuryOrbitRadius, mercuryInitialPosition, 
					mercuryOrbitRotation,mercuryPosition)


				//Venus model
				const venusModel = mat4.create();
				const venusScale = 0.7;
				const venusRotationPeriod = time * 60.0;
				const venusOrbitalPeriod = time * 2.4; // Radius of the venus's orbit
				const venusOrbitRadius = 5.60;

				// Initial venus position in the xz-plane
				const venusInitialPosition = [venusOrbitRadius, 0.0, 0.0];

				// Create a rotation matrix for the venus's orbit around the Sun
				const venusOrbitRotation = mat4.create();
				const venusPosition = vec3.create();
				assignAttributes(venusModel, venusScale, venusRotationPeriod, 
					venusOrbitalPeriod, venusOrbitRadius, venusInitialPosition, 
					venusOrbitRotation,venusPosition)
				
				//mars model
				const marsModel = mat4.create();
				const marsScale = 1.2;
				const marsRotationPeriod = time * 60.0;
				const marsOrbitalPeriod = time * 1.2; // Radius of the mars's orbit
				const marsOrbitRadius = 14.0;

				// Initial mars position in the xz-plane
				const marsInitialPosition = [marsOrbitRadius, 0.0, 0.0];

				// Create a rotation matrix for the mars's orbit around the Sun
				const marsOrbitRotation = mat4.create();
				const marsPosition = vec3.create();
				assignAttributes(marsModel, marsScale, marsRotationPeriod, 
					marsOrbitalPeriod, marsOrbitRadius, marsInitialPosition, 
					marsOrbitRotation,marsPosition)

				//mars jupiter
				const jupiterModel = mat4.create();
				const jupiterScale = 2;
				const jupiterRotationPeriod = time * 60.0;
				const jupiterOrbitalPeriod = time * 1; // Radius of the mars's orbit
				const jupiterOrbitRadius = 18.7;

				// Initial mars position in the xz-plane
				const jupiterInitialPosition = [jupiterOrbitRadius, 0.0, 0.0];

				// Create a rotation matrix for the jupiter's orbit around the Sun
				const jupiterOrbitRotation = mat4.create();
				const jupiterPosition = vec3.create();
				assignAttributes(jupiterModel, jupiterScale, jupiterRotationPeriod, 
					jupiterOrbitalPeriod, jupiterOrbitRadius, jupiterInitialPosition, 
					jupiterOrbitRotation,jupiterPosition)

				//mars saturn
				const saturnModel = mat4.create();
				const saturnScale = 1.6;
				const saturnRotationPeriod = time * 60.0;
				const saturnOrbitalPeriod = time * 0.89; // Radius of the mars's orbit
				const saturnOrbitRadius = 23.3;

				// Initial mars position in the xz-plane
				const saturnInitialPosition = [saturnOrbitRadius, 0.0, 0.0];

				// Create a rotation matrix for the saturn's orbit around the Sun
				const saturnOrbitRotation = mat4.create();
				const saturnPosition = vec3.create();
				assignAttributes(saturnModel, saturnScale, saturnRotationPeriod, 
					saturnOrbitalPeriod, saturnOrbitRadius, saturnInitialPosition, 
					saturnOrbitRotation,saturnPosition)

				//ring
				const ringModel = mat4.create();
				mat4.rotate(ringModel, ringModel, Math.radians(27), [0.0, 0.0, 1.0]);
				mat4.rotate(ringModel, ringModel, saturnRotationPeriod, [0.0, 1.0, 0.0]);
				mat4.scale(ringModel, ringModel, [2, 2, 2]);
				mat4.translate(ringModel, ringModel, saturnPosition);




				// Bind
				ubo.bind();
				ubo.uploadData("projection", proj);
				ubo.uploadData("view", view);
				ubo.uploadAll();

				// Render the sun
				renderSun(sunModel, sunTexture, sphereProgram);

				renderPlanet(earthModel,earthProgram, earthTexture, earthNormalTexture, earthSpecularTexture);

				// Render the moon
				renderPlanet(moonModel, moonProgram, moonTexture,moonTexture, moonTexture);

				//Render Mercury
				renderPlanet(mercuryModel, mercuryProgram, mercuryTexture, mercuryTexture, mercuryTexture);

				//Render Venus
				renderPlanet(venusModel, venusProgram, venusTexture, venusTexture, venusTexture);

				//Render mars
				renderPlanet(marsModel, marsProgram, marsTexture, marsTexture, marsTexture);

				//Render jupiter
				renderPlanet(jupiterModel, jupiterProgram, jupiterTexture, jupiterTexture, jupiterTexture);

				//Render saturn
				renderPlanet(saturnModel, saturnProgram, saturnTexture, saturnTexture, saturnTexture);

				//Render ring
				renderRing(ringModel, saturnRingProgram, saturnRingTexture);


				requestAnimationFrame(renderFunc);
			}

			document.addEventListener(
				"pointerlockchange",
				lockChangeAlert,
				false
			);
			document.addEventListener("keydown", function (event) {
		
				var cameraSpeed = 0.4; // Speed
				const cameraFrontNormalized = vec3.normalize(
					vec3.create(),
					cameraFront
				);
				const cameraRight = vec3.cross(
					vec3.create(),
					cameraFrontNormalized,
					cameraUp
				);
				switch (event.keyCode) {
					//translation
					case 87:
						vec3.add(
							cameraPosition,
							cameraPosition,
							vec3.scale(
								vec3.create(),
								cameraFrontNormalized,
								cameraSpeed
							)
						);
						break;
					case 68:
						vec3.add(
							cameraPosition,
							cameraPosition,
							vec3.scale(vec3.create(), cameraRight, cameraSpeed)
						);

						break;
					case 83:
						vec3.sub(
							cameraPosition,
							cameraPosition,
							vec3.scale(
								vec3.create(),
								cameraFrontNormalized,
								cameraSpeed
							)
						);
						break;
					case 65:
						vec3.sub(
							cameraPosition,
							cameraPosition,
							vec3.scale(vec3.create(), cameraRight, cameraSpeed)
						);
						break;
					case 81:
						cameraPosition[1] += cameraSpeed;
						break;
					case 69:
						cameraPosition[1] -= cameraSpeed;
						break;
				}
			});

			function mouse_callback(event) {
				let x = event.movementX;
				let y = event.movementY;
				const sensitivity = 0.1;

				if (firstMouse) {
					lastX = x;
					lastY = y;
					firstMouse = false;
				} else {
					x += lastX;
					y += lastY;
				}

				if (pitch > 89.0) pitch = 89.0;
				if (pitch < -89.0) pitch = -89.0;

				const xoffset = x - lastX;
				const yoffset = lastY - y;
				lastX = x;
				lastY = y;

				yaw += xoffset * sensitivity;
				pitch += yoffset * sensitivity;

				const direction = vec3.create();
				direction[0] =
					Math.cos(Math.radians(yaw)) * Math.cos(Math.radians(pitch));
				direction[1] = Math.sin(Math.radians(pitch));
				direction[2] =
					Math.sin(Math.radians(yaw)) * Math.cos(Math.radians(pitch));
				vec3.normalize(cameraFront, direction);
			}

			//Mouse movement event listener
			canvas.addEventListener("click", async () => {
				if (!document.pointerLockElement) {
					await canvas.requestPointerLock({
						unadjustedMovement: true,
					});
				}
			});

			function lockChangeAlert() {
				if (document.pointerLockElement === canvas) {
					console.log("The pointer lock status is now locked");
					document.addEventListener(
						"mousemove",
						mouse_callback,
						false
					);
				} else {
					console.log("The pointer lock status is now unlocked");
					document.removeEventListener(
						"mousemove",
						mouse_callback,
						false
					);
				}
			}

			function resizeCanvas() {
				const canvas = gl.canvas;
				// Lookup the size the browser is displaying the canvas in CSS pixels.
				const displayWidth = canvas.clientWidth;
				const displayHeight = canvas.clientHeight;

				// Check if the canvas is not the same size.
				const needResize =
					canvas.width !== displayWidth ||
					canvas.height !== displayHeight;

				if (needResize) {
					// Make the canvas the same size
					canvas.width = displayWidth;
					canvas.height = displayHeight;
					gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
				}
			}

			window.addEventListener("resize", resizeCanvas);
			resizeCanvas();

			renderFunc(0.0);
		</script>
	</body>
</html>
